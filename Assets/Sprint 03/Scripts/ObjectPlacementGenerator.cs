using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace CoffeeBytes.Week3
{
    public class ObjectPlacementGenerator : MonoBehaviour
    {
        [Header("Booleans")]
        [SerializeField] private bool withNoise = false;
        [SerializeField] private bool withRandomRotation = false;

        [Space(10)]

        [Header("Poisson Disc Settings")]
        [SerializeField] private float radius = 1f;
        [SerializeField] private Vector2 regionSize = Vector2.one;
        [SerializeField] private int rejectionSamples = 30;
        [SerializeField] private float rayStartHeight = 100;

        [Space(10)]

        [Header("Placement Values")]
        [SerializeField] private AnimationCurve densityCurve = AnimationCurve.Linear(0, 0, 1, 1);
        [SerializeField] private float minSlopeAngle = 0f;
        [SerializeField] private float maxSlopeAngle = 50f;
        [SerializeField] private float tiltValue = 5f;

        private float rayDist;
        private List<Vector2> points;
        private MapGenerator mapGenerator;
        private Quaternion treeQuaternion = Quaternion.identity;

        private void Awake()
        {
            mapGenerator = GetComponent<MapGenerator>();
        }

        public void GenerateTrees()
        {
            rayDist = rayStartHeight;
            //rayDist = rayStartHeight - mapGenerator.terrainData.waterHeight + 10f;
            Texture2D vegetationNoiseMap = Noise.GenerateVegetationTexture(50, 50, 5, 2, new Vector2(0, 0));
            points = PoissonDiscSampling.GeneratePoints(radius, regionSize, vegetationNoiseMap, withNoise, densityCurve, rejectionSamples);
            Debug.Log($"Amount of points generated by Poission = {points.Count}");
            foreach (Vector2 point in points)
            {
                RaycastHit hit;
                Vector3 rayOrigin = new Vector3(point.x + transform.position.x, rayStartHeight, point.y + transform.position.y);

                if (Physics.Raycast(rayOrigin, Vector3.down, out hit, rayDist))
                {
                    float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);

                    if (slopeAngle >= minSlopeAngle && slopeAngle <= maxSlopeAngle)
                    {
                            foreach (VegetationType type in mapGenerator.vegetationData.vegetationTypes)
                            {
                                if (withRandomRotation)
                                {
                                    treeQuaternion = RandomRotations();
                                }
                                Instantiate(type.prefabs[Random.Range(0, type.prefabs.Length)], hit.point, treeQuaternion, transform);
                            }
                        
                    }
                }
            }
        }

        private Quaternion RandomRotations()
        {
            float randomYRotation = Random.Range(0f, 360f);
            float randomXRotation = Random.Range(0f, tiltValue);
            float randomZRotation = Random.Range(0f, tiltValue);

            Quaternion randomRotation = Quaternion.Euler(randomXRotation, randomYRotation, randomZRotation);
            return randomRotation;
        }
    }
}